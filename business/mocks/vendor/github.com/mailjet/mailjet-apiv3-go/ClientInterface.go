// Code generated by mockery v2.14.0. DO NOT EDIT.

package mocks

import (
	http "net/http"

	mailjet "github.com/mailjet/mailjet-apiv3-go"
	mock "github.com/stretchr/testify/mock"
)

// ClientInterface is an autogenerated mock type for the ClientInterface type
type ClientInterface struct {
	mock.Mock
}

// APIKeyPrivate provides a mock function with given fields:
func (_m *ClientInterface) APIKeyPrivate() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// APIKeyPublic provides a mock function with given fields:
func (_m *ClientInterface) APIKeyPublic() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Client provides a mock function with given fields:
func (_m *ClientInterface) Client() *http.Client {
	ret := _m.Called()

	var r0 *http.Client
	if rf, ok := ret.Get(0).(func() *http.Client); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Client)
		}
	}

	return r0
}

// Delete provides a mock function with given fields: mr
func (_m *ClientInterface) Delete(mr *mailjet.Request) error {
	ret := _m.Called(mr)

	var r0 error
	if rf, ok := ret.Get(0).(func(*mailjet.Request) error); ok {
		r0 = rf(mr)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Get provides a mock function with given fields: mr, resp, options
func (_m *ClientInterface) Get(mr *mailjet.Request, resp interface{}, options ...mailjet.RequestOptions) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, mr, resp)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(*mailjet.Request, interface{}, ...mailjet.RequestOptions) error); ok {
		r0 = rf(mr, resp, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// List provides a mock function with given fields: resource, resp, options
func (_m *ClientInterface) List(resource string, resp interface{}, options ...mailjet.RequestOptions) (int, int, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, resource, resp)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 int
	if rf, ok := ret.Get(0).(func(string, interface{}, ...mailjet.RequestOptions) int); ok {
		r0 = rf(resource, resp, options...)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 int
	if rf, ok := ret.Get(1).(func(string, interface{}, ...mailjet.RequestOptions) int); ok {
		r1 = rf(resource, resp, options...)
	} else {
		r1 = ret.Get(1).(int)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(string, interface{}, ...mailjet.RequestOptions) error); ok {
		r2 = rf(resource, resp, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Post provides a mock function with given fields: fmr, resp, options
func (_m *ClientInterface) Post(fmr *mailjet.FullRequest, resp interface{}, options ...mailjet.RequestOptions) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, fmr, resp)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(*mailjet.FullRequest, interface{}, ...mailjet.RequestOptions) error); ok {
		r0 = rf(fmr, resp, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Put provides a mock function with given fields: fmr, onlyFields, options
func (_m *ClientInterface) Put(fmr *mailjet.FullRequest, onlyFields []string, options ...mailjet.RequestOptions) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, fmr, onlyFields)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(*mailjet.FullRequest, []string, ...mailjet.RequestOptions) error); ok {
		r0 = rf(fmr, onlyFields, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SendMail provides a mock function with given fields: data
func (_m *ClientInterface) SendMail(data *mailjet.InfoSendMail) (*mailjet.SentResult, error) {
	ret := _m.Called(data)

	var r0 *mailjet.SentResult
	if rf, ok := ret.Get(0).(func(*mailjet.InfoSendMail) *mailjet.SentResult); ok {
		r0 = rf(data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mailjet.SentResult)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*mailjet.InfoSendMail) error); ok {
		r1 = rf(data)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendMailSMTP provides a mock function with given fields: info
func (_m *ClientInterface) SendMailSMTP(info *mailjet.InfoSMTP) error {
	ret := _m.Called(info)

	var r0 error
	if rf, ok := ret.Get(0).(func(*mailjet.InfoSMTP) error); ok {
		r0 = rf(info)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetClient provides a mock function with given fields: client
func (_m *ClientInterface) SetClient(client *http.Client) {
	_m.Called(client)
}

type mockConstructorTestingTNewClientInterface interface {
	mock.TestingT
	Cleanup(func())
}

// NewClientInterface creates a new instance of ClientInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewClientInterface(t mockConstructorTestingTNewClientInterface) *ClientInterface {
	mock := &ClientInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
